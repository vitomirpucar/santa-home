<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Santa's Home 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #93C5FD, #60A5FA);
        }
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 20px;
            background: rgba(185, 28, 28, 0.9);
            color: white;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10;
        }
        #header h1 {
            font-size: 1.3em;
            margin-bottom: 4px;
        }
        #header p {
            font-size: 0.75em;
        }
        #container {
            width: 100%;
            height: 100vh;
            cursor: grab;
        }
        #container:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üéÖ Santa's Home at the North Pole üè† by Vita</h1>
        <p>üíª Levi klik = rotacija ‚Ä¢ Desni klik = fokus ‚Ä¢ Toƒçkiƒá = zoom ‚Ä¢ Razmaknica = vatromet</p>
        <p>üì± Jedan prst = rotacija ‚Ä¢ Dva prsta = zoom ‚Ä¢ Tap = vatromet</p>
        <button id="musicBtn1" style="margin-top: 8px; margin-right: 8px; padding: 6px 14px; background: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
            üîá Pesma 1
        </button>
        <button id="musicBtn2" style="margin-top: 8px; padding: 6px 14px; background: #fff; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
            üîá Pesma 2
        </button>
    </div>
    <div id="container"></div>
    <audio id="bgMusic1" loop preload="auto">
        <source src="WinterTown.ogg" type="audio/ogg">
        <source src="WinterTown.mp3" type="audio/mpeg">
    </audio>
    <audio id="bgMusic2" loop preload="auto">
        <source src="WinterTown2.ogg" type="audio/ogg">
        <source src="WinterTown2.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('container');
        const musicBtn1 = document.getElementById('musicBtn1');
        const musicBtn2 = document.getElementById('musicBtn2');
        const bgMusic1 = document.getElementById('bgMusic1');
        const bgMusic2 = document.getElementById('bgMusic2');
        let rotation = { x: 0, y: 0 };
        let zoom = 20;
        let lookAtPoint = { x: 0, y: 5, z: 0 };
        let audioUnlocked = false;

        // Try to unlock audio on first user interaction
        function unlockAudio() {
            if (!audioUnlocked) {
                bgMusic1.play().then(() => {
                    bgMusic1.pause();
                    bgMusic1.currentTime = 0;
                    audioUnlocked = true;
                    console.log('Audio unlocked!');
                }).catch(err => {
                    console.log('Still locked:', err);
                });
            }
        }

        // Stop all music
        function stopAllMusic() {
            bgMusic1.pause();
            bgMusic2.pause();
            musicBtn1.textContent = 'üîá Pesma 1';
            musicBtn2.textContent = 'üîá Pesma 2';
        }

        // Music 1 toggle
        musicBtn1.addEventListener('click', function() {
            console.log('Pesma 1 kliknuta!');
            unlockAudio();
            
            if (bgMusic1.paused) {
                stopAllMusic();
                bgMusic1.play().then(function() {
                    console.log('Pesma 1 ide!');
                    musicBtn1.textContent = 'üîä Pesma 1';
                }).catch(function(err) {
                    console.log('Gre≈°ka:', err);
                    alert('Molim te klikni ponovo na dugme!');
                });
            } else {
                bgMusic1.pause();
                musicBtn1.textContent = 'üîá Pesma 1';
            }
        });

        // Music 2 toggle
        musicBtn2.addEventListener('click', function() {
            console.log('Pesma 2 kliknuta!');
            unlockAudio();
            
            if (bgMusic2.paused) {
                stopAllMusic();
                bgMusic2.play().then(function() {
                    console.log('Pesma 2 ide!');
                    musicBtn2.textContent = 'üîä Pesma 2';
                }).catch(function(err) {
                    console.log('Gre≈°ka:', err);
                    alert('Molim te klikni ponovo na dugme!');
                });
            } else {
                bgMusic2.pause();
                musicBtn2.textContent = 'üîá Pesma 2';
            }
        });

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a20);
        scene.fog = new THREE.Fog(0x0a0a20, 50, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 16, zoom);
        camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0x8080ff, 0.4);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Moon
        const moonGeom = new THREE.SphereGeometry(3, 32, 32);
        const moonMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffcc,
            emissive: 0xffffcc,
            emissiveIntensity: 0.8
        });
        const moon = new THREE.Mesh(moonGeom, moonMat);
        moon.position.set(-30, 15, -30);
        scene.add(moon);

        // Ground
        const groundGeom = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const ground = new THREE.Mesh(groundGeom, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // House
        const houseGeom = new THREE.BoxGeometry(8, 5, 8);
        const houseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const house = new THREE.Mesh(houseGeom, houseMat);
        house.position.y = 2.5;
        house.castShadow = true;
        house.receiveShadow = true;
        scene.add(house);

        // Snow roof
        const snowRoofGeom = new THREE.ConeGeometry(6.3, 4.5, 4);
        const snowRoofMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const snowRoof = new THREE.Mesh(snowRoofGeom, snowRoofMat);
        snowRoof.position.y = 7.25;
        snowRoof.rotation.y = Math.PI / 4;
        snowRoof.castShadow = true;
        scene.add(snowRoof);

        // Chimney
        const chimneyGeom = new THREE.BoxGeometry(1, 2.5, 1);
        const chimneyMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
        const chimney = new THREE.Mesh(chimneyGeom, chimneyMat);
        chimney.position.set(2, 7.5, 2);
        chimney.castShadow = true;
        scene.add(chimney);

        // Snow on chimney
        const chimneySnowGeom = new THREE.BoxGeometry(1.2, 0.3, 1.2);
        const chimneySnow = new THREE.Mesh(chimneySnowGeom, snowRoofMat);
        chimneySnow.position.set(2, 8.9, 2);
        scene.add(chimneySnow);

        // Door
        const doorGeom = new THREE.BoxGeometry(1.5, 3, 0.2);
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const door = new THREE.Mesh(doorGeom, doorMat);
        door.position.set(0, 1.5, 4.1);
        scene.add(door);

        // Windows
        const windowGeom = new THREE.BoxGeometry(1.2, 1.2, 0.2);
        const windowMat = new THREE.MeshStandardMaterial({ 
            color: 0xFFFF00, 
            emissive: 0xFFFF00, 
            emissiveIntensity: 0.8
        });
        windowMat.userData.noBlinking = true;
        
        const window1 = new THREE.Mesh(windowGeom, windowMat);
        window1.position.set(-2.5, 3, 4.1);
        scene.add(window1);
        
        // Add point light to window 1
        const windowLight1 = new THREE.PointLight(0xFFFF00, 1, 8);
        windowLight1.position.set(-2.5, 3, 4.5);
        scene.add(windowLight1);

        const window2 = new THREE.Mesh(windowGeom, windowMat);
        window2.position.set(2.5, 3, 4.1);
        scene.add(window2);
        
        // Add point light to window 2
        const windowLight2 = new THREE.PointLight(0xFFFF00, 1, 8);
        windowLight2.position.set(2.5, 3, 4.5);
        scene.add(windowLight2);

        // Christmas lights on house
        const lightColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF];
        for (let i = 0; i < 12; i++) {
            const bulbGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const bulbMat = new THREE.MeshStandardMaterial({ 
                color: lightColors[i % lightColors.length],
                emissive: lightColors[i % lightColors.length],
                emissiveIntensity: 0.8
            });
            const bulb = new THREE.Mesh(bulbGeom, bulbMat);
            const angle = (i / 12) * Math.PI * 2;
            bulb.position.set(
                Math.cos(angle) * 5.5,
                5.2,
                Math.sin(angle) * 5.5
            );
            scene.add(bulb);
        }

        // Trees with snow
        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            
            const trunkGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 0.75;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);

            const foliageGeom = new THREE.ConeGeometry(1.5, 3, 8);
            const colors = [];
            const positionAttr = foliageGeom.attributes.position;
            
            for (let i = 0; i < positionAttr.count; i++) {
                if (Math.random() > 0.6) {
                    colors.push(1, 1, 1);
                } else {
                    colors.push(0.13, 0.55, 0.13);
                }
            }
            
            foliageGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const foliageMat = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                vertexColors: true 
            });
            const foliage = new THREE.Mesh(foliageGeom, foliageMat);
            foliage.position.y = 3;
            foliage.castShadow = true;
            foliage.receiveShadow = true;
            treeGroup.add(foliage);

            // Christmas lights on tree
            const treeLightColors = [0xFF0000, 0xFFFF00, 0x0000FF, 0xFF00FF];
            for (let j = 0; j < 6; j++) {
                const treeBulbGeom = new THREE.SphereGeometry(0.1, 8, 8);
                const treeBulbMat = new THREE.MeshStandardMaterial({ 
                    color: treeLightColors[j % treeLightColors.length],
                    emissive: treeLightColors[j % treeLightColors.length],
                    emissiveIntensity: 0.9
                });
                const treeBulb = new THREE.Mesh(treeBulbGeom, treeBulbMat);
                const treeAngle = (j / 6) * Math.PI * 2;
                const treeRadius = 1.2 - (j * 0.15);
                treeBulb.position.set(
                    Math.cos(treeAngle) * treeRadius,
                    2 + j * 0.3,
                    Math.sin(treeAngle) * treeRadius
                );
                treeGroup.add(treeBulb);
            }

            treeGroup.position.set(x, 0, z);
            return treeGroup;
        }

        scene.add(createTree(-8, 5));
        scene.add(createTree(8, 5));
        
        // Special big tree on left back
        const bigTreeGroup = new THREE.Group();
        
        const bigTrunkGeom = new THREE.CylinderGeometry(0.4, 0.4, 2, 16);
        const bigTrunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const bigTrunk = new THREE.Mesh(bigTrunkGeom, bigTrunkMat);
        bigTrunk.position.y = 1;
        bigTrunk.castShadow = true;
        bigTrunk.receiveShadow = true;
        bigTreeGroup.add(bigTrunk);

        const bigFoliageGeom = new THREE.ConeGeometry(2.5, 5, 8);
        const bigColors = [];
        const bigPositionAttr = bigFoliageGeom.attributes.position;
        
        for (let i = 0; i < bigPositionAttr.count; i++) {
            if (Math.random() > 0.6) {
                bigColors.push(1, 1, 1);
            } else {
                bigColors.push(0.13, 0.55, 0.13);
            }
        }
        
        bigFoliageGeom.setAttribute('color', new THREE.Float32BufferAttribute(bigColors, 3));
        
        const bigFoliageMat = new THREE.MeshStandardMaterial({ 
            color: 0x228B22,
            vertexColors: true 
        });
        const bigFoliage = new THREE.Mesh(bigFoliageGeom, bigFoliageMat);
        bigFoliage.position.y = 4.5;
        bigFoliage.castShadow = true;
        bigFoliage.receiveShadow = true;
        bigTreeGroup.add(bigFoliage);

        // Double the lights for big tree (12 lights)
        const bigTreeLightColors = [0xFF0000, 0xFFFF00, 0x0000FF, 0xFF00FF, 0x00FF00];
        for (let j = 0; j < 12; j++) {
            const bigTreeBulbGeom = new THREE.SphereGeometry(0.12, 8, 8);
            const bigTreeBulbMat = new THREE.MeshStandardMaterial({ 
                color: bigTreeLightColors[j % bigTreeLightColors.length],
                emissive: bigTreeLightColors[j % bigTreeLightColors.length],
                emissiveIntensity: 1
            });
            const bigTreeBulb = new THREE.Mesh(bigTreeBulbGeom, bigTreeBulbMat);
            const bigTreeAngle = (j / 12) * Math.PI * 2;
            const bigTreeRadius = 2 - (j * 0.12);
            bigTreeBulb.position.set(
                Math.cos(bigTreeAngle) * bigTreeRadius,
                2.5 + j * 0.35,
                Math.sin(bigTreeAngle) * bigTreeRadius
            );
            bigTreeGroup.add(bigTreeBulb);
        }

        bigTreeGroup.position.set(-8, 0, -5);
        scene.add(bigTreeGroup);
        
        // Extra large tree on right back
        const extraBigTreeGroup = new THREE.Group();
        
        const extraBigTrunkGeom = new THREE.CylinderGeometry(0.5, 0.5, 2.5, 16);
        const extraBigTrunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const extraBigTrunk = new THREE.Mesh(extraBigTrunkGeom, extraBigTrunkMat);
        extraBigTrunk.position.y = 1.25;
        extraBigTrunk.castShadow = true;
        extraBigTrunk.receiveShadow = true;
        extraBigTreeGroup.add(extraBigTrunk);

        const extraBigFoliageGeom = new THREE.ConeGeometry(3.5, 7, 8);
        const extraBigColors = [];
        const extraBigPositionAttr = extraBigFoliageGeom.attributes.position;
        
        for (let i = 0; i < extraBigPositionAttr.count; i++) {
            if (Math.random() > 0.6) {
                extraBigColors.push(1, 1, 1);
            } else {
                extraBigColors.push(0.13, 0.55, 0.13);
            }
        }
        
        extraBigFoliageGeom.setAttribute('color', new THREE.Float32BufferAttribute(extraBigColors, 3));
        
        const extraBigFoliageMat = new THREE.MeshStandardMaterial({ 
            color: 0x228B22,
            vertexColors: true 
        });
        const extraBigFoliage = new THREE.Mesh(extraBigFoliageGeom, extraBigFoliageMat);
        extraBigFoliage.position.y = 6;
        extraBigFoliage.castShadow = true;
        extraBigFoliage.receiveShadow = true;
        extraBigTreeGroup.add(extraBigFoliage);

        // Even more lights for extra big tree (24 lights)
        const extraBigTreeLightColors = [0xFF0000, 0xFFFF00, 0x0000FF, 0xFF00FF, 0x00FF00, 0xFFA500];
        for (let j = 0; j < 24; j++) {
            const extraBigTreeBulbGeom = new THREE.SphereGeometry(0.14, 8, 8);
            const extraBigTreeBulbMat = new THREE.MeshStandardMaterial({ 
                color: extraBigTreeLightColors[j % extraBigTreeLightColors.length],
                emissive: extraBigTreeLightColors[j % extraBigTreeLightColors.length],
                emissiveIntensity: 1
            });
            const extraBigTreeBulb = new THREE.Mesh(extraBigTreeBulbGeom, extraBigTreeBulbMat);
            const extraBigTreeAngle = (j / 24) * Math.PI * 2;
            const extraBigTreeRadius = 2.8 - (j * 0.1);
            extraBigTreeBulb.position.set(
                Math.cos(extraBigTreeAngle) * extraBigTreeRadius,
                3 + j * 0.25,
                Math.sin(extraBigTreeAngle) * extraBigTreeRadius
            );
            extraBigTreeGroup.add(extraBigTreeBulb);
        }

        extraBigTreeGroup.position.set(8, 0, -5);
        scene.add(extraBigTreeGroup);

        // Gift boxes
        function createGift(x, z, color1, color2) {
            const giftGroup = new THREE.Group();
            
            const boxGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const boxMat = new THREE.MeshStandardMaterial({ color: color1 });
            const box = new THREE.Mesh(boxGeom, boxMat);
            box.position.y = 0.4;
            box.castShadow = true;
            box.receiveShadow = true;
            giftGroup.add(box);
            
            const ribbonGeom = new THREE.BoxGeometry(0.9, 0.1, 0.1);
            const ribbonMat = new THREE.MeshStandardMaterial({ color: color2 });
            const ribbon1 = new THREE.Mesh(ribbonGeom, ribbonMat);
            ribbon1.position.y = 0.4;
            giftGroup.add(ribbon1);
            
            const ribbon2 = new THREE.Mesh(ribbonGeom, ribbonMat);
            ribbon2.position.y = 0.4;
            ribbon2.rotation.y = Math.PI / 2;
            giftGroup.add(ribbon2);
            
            const bowGeom = new THREE.SphereGeometry(0.2, 8, 8);
            const bow = new THREE.Mesh(bowGeom, ribbonMat);
            bow.position.y = 0.9;
            giftGroup.add(bow);
            
            giftGroup.position.set(x, 0, z);
            giftGroup.rotation.y = Math.random() * Math.PI;
            return giftGroup;
        }

        scene.add(createGift(-3, 7, 0xFF0000, 0xFFD700));
        scene.add(createGift(-2, 7.5, 0x0000FF, 0xC0C0C0));
        scene.add(createGift(-2.5, 8, 0x00FF00, 0xFF0000));
        scene.add(createGift(3, 7, 0xFF00FF, 0xFFD700));
        scene.add(createGift(2, 7.5, 0xFFFF00, 0xFF0000));

        // Fence
        const fenceMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        for (let i = -5; i <= 5; i++) {
            if (Math.abs(i) > 1) {
                const postGeom = new THREE.BoxGeometry(0.2, 1.5, 0.2);
                const post = new THREE.Mesh(postGeom, fenceMat);
                post.position.set(i * 2, 0.75, 10);
                post.castShadow = true;
                scene.add(post);
                
                if (i < 5) {
                    const railGeom = new THREE.BoxGeometry(2, 0.1, 0.1);
                    const rail = new THREE.Mesh(railGeom, fenceMat);
                    rail.position.set(i * 2 + 1, 1, 10);
                    scene.add(rail);
                }
            }
        }

        // Snowman
        const snowmanGroup = new THREE.Group();
        
        const bottomGeom = new THREE.SphereGeometry(1, 16, 16);
        const snowmanMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const bottom = new THREE.Mesh(bottomGeom, snowmanMat);
        bottom.position.y = 1;
        bottom.castShadow = true;
        snowmanGroup.add(bottom);
        
        const middleGeom = new THREE.SphereGeometry(0.75, 16, 16);
        const middle = new THREE.Mesh(middleGeom, snowmanMat);
        middle.position.y = 2.25;
        middle.castShadow = true;
        snowmanGroup.add(middle);
        
        const headGeom2 = new THREE.SphereGeometry(0.5, 16, 16);
        const head2 = new THREE.Mesh(headGeom2, snowmanMat);
        head2.position.y = 3.25;
        head2.castShadow = true;
        snowmanGroup.add(head2);
        
        const noseGeom = new THREE.ConeGeometry(0.1, 0.5, 8);
        const noseMat = new THREE.MeshStandardMaterial({ color: 0xFF6347 });
        const nose = new THREE.Mesh(noseGeom, noseMat);
        nose.position.set(0, 3.25, 0.5);
        nose.rotation.x = Math.PI / 2;
        snowmanGroup.add(nose);
        
        const eyeGeom = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
        leftEye.position.set(-0.15, 3.35, 0.45);
        snowmanGroup.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
        rightEye.position.set(0.15, 3.35, 0.45);
        snowmanGroup.add(rightEye);
        
        for (let i = 0; i < 5; i++) {
            const mouthPiece = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                eyeMat
            );
            const angle = (i - 2) * 0.15;
            mouthPiece.position.set(
                Math.sin(angle) * 0.3,
                3.05 + Math.abs(i - 2) * 0.05,
                0.45
            );
            snowmanGroup.add(mouthPiece);
        }
        
        for (let i = 0; i < 3; i++) {
            const button = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 8, 8),
                eyeMat
            );
            button.position.set(0, 2.5 - i * 0.35, 0.7);
            snowmanGroup.add(button);
        }
        
        const hatBrimGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 16);
        const hatMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const hatBrim = new THREE.Mesh(hatBrimGeom, hatMat);
        hatBrim.position.y = 3.75;
        snowmanGroup.add(hatBrim);
        
        const hatTopGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 16);
        const hatTop = new THREE.Mesh(hatTopGeom, hatMat);
        hatTop.position.y = 4.15;
        snowmanGroup.add(hatTop);
        
        const armGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8);
        const armMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        
        const leftArm = new THREE.Mesh(armGeom, armMat);
        leftArm.position.set(-0.7, 2.3, 0);
        leftArm.rotation.z = Math.PI / 3;
        leftArm.castShadow = true;
        snowmanGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeom, armMat);
        rightArm.position.set(0.7, 2.3, 0);
        rightArm.rotation.z = -Math.PI / 3;
        rightArm.castShadow = true;
        snowmanGroup.add(rightArm);
        
        snowmanGroup.position.set(-5, 0, 8);
        scene.add(snowmanGroup);

        // Santa's sleigh behind house
        const sleighGroup = new THREE.Group();
        
        // Sleigh body
        const sleighBodyGeom = new THREE.BoxGeometry(3, 0.8, 1.5);
        const sleighMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
        const sleighBody = new THREE.Mesh(sleighBodyGeom, sleighMat);
        sleighBody.position.y = 0.8;
        sleighBody.castShadow = true;
        sleighGroup.add(sleighBody);
        
        // Sleigh sides
        const sideGeom = new THREE.BoxGeometry(3.2, 1.2, 0.15);
        const leftSide = new THREE.Mesh(sideGeom, sleighMat);
        leftSide.position.set(0, 1.2, 0.82);
        sleighGroup.add(leftSide);
        
        const rightSide = new THREE.Mesh(sideGeom, sleighMat);
        rightSide.position.set(0, 1.2, -0.82);
        sleighGroup.add(rightSide);
        
        // Sleigh runners
        const runnerGeom = new THREE.BoxGeometry(3.5, 0.15, 0.2);
        const runnerMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0 });
        const runner1 = new THREE.Mesh(runnerGeom, runnerMat);
        runner1.position.set(0, 0.07, 0.6);
        sleighGroup.add(runner1);
        
        const runner2 = new THREE.Mesh(runnerGeom, runnerMat);
        runner2.position.set(0, 0.07, -0.6);
        sleighGroup.add(runner2);
        
        // Front curves of runners
        const curveGeom = new THREE.TorusGeometry(0.4, 0.1, 8, 16, Math.PI);
        const curve1 = new THREE.Mesh(curveGeom, runnerMat);
        curve1.position.set(1.75, 0.4, 0.6);
        curve1.rotation.z = -Math.PI / 2;
        sleighGroup.add(curve1);
        
        const curve2 = new THREE.Mesh(curveGeom, runnerMat);
        curve2.position.set(1.75, 0.4, -0.6);
        curve2.rotation.z = -Math.PI / 2;
        sleighGroup.add(curve2);
        
        sleighGroup.position.set(0, 0, -6);
        sleighGroup.rotation.y = Math.PI;
        scene.add(sleighGroup);

        // Skis on the right side
        const skiGroup = new THREE.Group();
        
        for (let i = 0; i < 2; i++) {
            // Ski
            const skiGeom = new THREE.BoxGeometry(0.15, 0.1, 2);
            const skiMat = new THREE.MeshStandardMaterial({ color: 0xFF6347 });
            const ski = new THREE.Mesh(skiGeom, skiMat);
            ski.position.set(i * 0.3, 0.05, 0);
            ski.castShadow = true;
            skiGroup.add(ski);
            
            // Ski tip curve
            const tipGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const tip = new THREE.Mesh(tipGeom, skiMat);
            tip.position.set(i * 0.3, 0.15, 1);
            tip.scale.z = 1.5;
            skiGroup.add(tip);
            
            // Binding
            const bindingGeom = new THREE.BoxGeometry(0.2, 0.05, 0.3);
            const bindingMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const binding = new THREE.Mesh(bindingGeom, bindingMat);
            binding.position.set(i * 0.3, 0.12, -0.2);
            skiGroup.add(binding);
        }
        
        // Ski poles
        for (let i = 0; i < 2; i++) {
            const poleGeom = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0 });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.set(i * 0.3 + 0.5, 0.75, 0.5);
            pole.rotation.x = Math.PI / 6;
            pole.castShadow = true;
            skiGroup.add(pole);
            
            // Pole basket
            const basketGeom = new THREE.TorusGeometry(0.08, 0.02, 8, 16);
            const basket = new THREE.Mesh(basketGeom, poleMat);
            basket.position.set(i * 0.3 + 0.5, 0.05, 1.1);
            basket.rotation.x = Math.PI / 2;
            skiGroup.add(basket);
        }
        
        skiGroup.position.set(7, 0, 2);
        skiGroup.rotation.y = -Math.PI / 6;
        scene.add(skiGroup);

        // Street lamps (lanterns)
        function createLantern(x, z) {
            const lanternGroup = new THREE.Group();
            
            // Pole
            const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 1.5;
            pole.castShadow = true;
            lanternGroup.add(pole);
            
            // Lantern base
            const baseGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 6);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const base = new THREE.Mesh(baseGeom, baseMat);
            base.position.y = 3.1;
            lanternGroup.add(base);
            
            // Glass box
            const glassGeom = new THREE.BoxGeometry(0.4, 0.6, 0.4);
            const glassMat = new THREE.MeshStandardMaterial({ 
                color: 0xffdd88,
                transparent: true,
                opacity: 0.6,
                emissive: 0xffaa00,
                emissiveIntensity: 0.8
            });
            const glass = new THREE.Mesh(glassGeom, glassMat);
            glass.position.y = 3.5;
            lanternGroup.add(glass);
            
            // Light bulb inside (mark as non-blinking)
            const bulbGeom = new THREE.SphereGeometry(0.15, 16, 16);
            const bulbMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffcc,
                emissive: 0xffffcc,
                emissiveIntensity: 1.2
            });
            bulbMat.userData.noBlinking = true; // Mark to not blink
            const bulb = new THREE.Mesh(bulbGeom, bulbMat);
            bulb.position.y = 3.5;
            lanternGroup.add(bulb);
            
            // Top cap
            const capGeom = new THREE.ConeGeometry(0.3, 0.3, 6);
            const cap = new THREE.Mesh(capGeom, baseMat);
            cap.position.y = 3.95;
            lanternGroup.add(cap);
            
            // Point light for illumination
            const pointLight = new THREE.PointLight(0xffaa44, 1.5, 10);
            pointLight.position.y = 3.5;
            pointLight.castShadow = true;
            lanternGroup.add(pointLight);
            
            lanternGroup.position.set(x, 0, z);
            return lanternGroup;
        }
        
        // Front lanterns
        scene.add(createLantern(-10, 10));
        scene.add(createLantern(10, 10));
        
        // Back lanterns
        scene.add(createLantern(-10, -7));
        scene.add(createLantern(2, -7)); // Near sleigh

        // Snowflakes - optimized with shared geometry
        const snowflakes = [];
        const snowGeom = new THREE.SphereGeometry(0.1, 6, 6); // Less segments = faster
        const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        
        for (let i = 0; i < 600; i++) {
            const snowflake = new THREE.Mesh(snowGeom, snowMat);
            snowflake.position.set(
                Math.random() * 60 - 30,
                Math.random() * 30,
                Math.random() * 60 - 30
            );
            snowflake.castShadow = false; // No shadows for snowflakes = faster
            snowflakes.push(snowflake);
            scene.add(snowflake);
        }

        // Smoke
        const smokeParticles=[];
        const smokeGeometry=new THREE.SphereGeometry(0.3,8,8);
        const smokeMaterial=new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.4,depthWrite:false});
        function createSmoke(){
            const particle=new THREE.Mesh(smokeGeometry,smokeMaterial.clone());
            particle.position.set(2+(Math.random()-0.5)*0.4,9.2,2+(Math.random()-0.5)*0.4);
            particle.velocity={x:(Math.random()-0.5)*0.02,y:0.03+Math.random()*0.03,z:(Math.random()-0.5)*0.02};
            particle.life=1.0;
            scene.add(particle);
            smokeParticles.push(particle);
        }
        let smokeTimer=0;
        
        // Fireworks system
        const fireworks = [];
        
        class Firework {
            constructor() {
                this.particles = [];
                this.dead = false;
                
                const colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const startX = Math.random() * 40 - 20;
                const startY = 15 + Math.random() * 10;
                const startZ = Math.random() * 40 - 20;
                
                // Central light for the firework
                this.centerLight = new THREE.PointLight(color, 8, 20);
                this.centerLight.position.set(startX, startY, startZ);
                scene.add(this.centerLight);
                
                // Create particles
                for (let i = 0; i < 100; i++) {
                    const particleGeom = new THREE.SphereGeometry(0.2, 8, 8);
                    const particleMat = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 2
                    });
                    const particle = new THREE.Mesh(particleGeom, particleMat);
                    particle.position.set(startX, startY, startZ);
                    
                    const speed = 0.3 + Math.random() * 0.4;
                    const angle1 = Math.random() * Math.PI * 2;
                    const angle2 = Math.random() * Math.PI;
                    
                    particle.velocity = {
                        x: Math.sin(angle1) * Math.cos(angle2) * speed,
                        y: Math.sin(angle2) * speed,
                        z: Math.cos(angle1) * Math.cos(angle2) * speed
                    };
                    
                    particle.life = 1;
                    this.particles.push(particle);
                    scene.add(particle);
                }
            }
            
            update() {
                let allDead = true;
                let centerX = 0, centerY = 0, centerZ = 0;
                let count = 0;
                
                this.particles.forEach(particle => {
                    if (particle.life > 0) {
                        particle.position.x += particle.velocity.x;
                        particle.position.y += particle.velocity.y;
                        particle.position.z += particle.velocity.z;
                        
                        particle.velocity.y -= 0.02;
                        particle.life -= 0.015;
                        
                        particle.material.opacity = particle.life;
                        particle.material.transparent = true;
                        particle.material.emissiveIntensity = 2 * particle.life;
                        
                        centerX += particle.position.x;
                        centerY += particle.position.y;
                        centerZ += particle.position.z;
                        count++;
                        
                        allDead = false;
                    }
                });
                
                // Update center light position
                if (count > 0 && this.centerLight) {
                    this.centerLight.position.set(centerX / count, centerY / count, centerZ / count);
                    this.centerLight.intensity = 8 * (count / 100);
                }
                
                if (allDead) {
                    this.dead = true;
                    this.particles.forEach(p => scene.remove(p));
                    if (this.centerLight) scene.remove(this.centerLight);
                }
            }
        }
        
        function launchFirework() {
            fireworks.push(new Firework());
        }
        
        // Spacebar to launch firework
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                launchFirework();
            }
        });

        // Collect all lights for blinking (only Christmas lights, not windows/lanterns)
        const allLights = [];
        scene.traverse((object) => {
            if (object.isMesh && object.material.emissive && object.material.emissiveIntensity > 0) {
                // Skip if marked as non-blinking (lanterns, windows)
                if (object.material.userData.noBlinking) {
                    return;
                }
                // Only add if it's a small sphere (Christmas lights on trees/house)
                if (object.geometry.type === 'SphereGeometry' && 
                    object.geometry.parameters.radius < 0.2) {
                    allLights.push({
                        material: object.material,
                        originalIntensity: object.material.emissiveIntensity,
                        blinkSpeed: Math.random() * 2 + 1
                    });
                }
            }
        });

        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.05;

            //Smoke animate
            smokeTimer++;
            if(smokeTimer>12){createSmoke();smokeTimer=0;}
            smokeParticles.forEach((p,i)=>{
                p.position.x+=p.velocity.x;
                p.position.y+=p.velocity.y;
                p.position.z+=p.velocity.z;
                p.velocity.x+=(Math.random()-0.5)*0.002;
                p.velocity.z+=(Math.random()-0.5)*0.002;
                p.velocity.y*=0.99;
                p.life-=0.004;
                p.material.opacity=p.life*0.4;
                p.scale.setScalar(p.life*2);
                if(p.life<=0){scene.remove(p);smokeParticles.splice(i,1);}
            });
            
            // Blink lights - much stronger effect
            allLights.forEach((light, index) => {
                const offset = index * 0.5;
                const pulse = Math.sin(time * light.blinkSpeed + offset);
                if (pulse > 0) {
                    light.material.emissiveIntensity = light.originalIntensity;
                } else {
                    light.material.emissiveIntensity = 0.1;
                }
            });

            // Update fireworks
            fireworks.forEach((fw, index) => {
                fw.update();
                if (fw.dead) {
                    fireworks.splice(index, 1);
                }
            });

            snowflakes.forEach(flake => {
                flake.position.y -= 0.05;
                if (flake.position.y < 0) {
                    flake.position.y = 30;
                }
            });

            scene.rotation.y = rotation.y;
            scene.rotation.x = rotation.x;
            camera.position.z = zoom;
            camera.lookAt(lookAtPoint.x, lookAtPoint.y, lookAtPoint.z);

            renderer.render(scene, camera);
        }
        animate();

        // Mouse controls
        container.addEventListener('mousemove', (e) => {
            if (e.buttons === 1) {
                const deltaX = e.movementX || 0;
                const deltaY = e.movementY || 0;
                
                rotation.y += deltaX * 0.005;
                rotation.x += deltaY * 0.005;
                
                // Limit vertical rotation
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
            }
        });

        // Right click to set focus point
        container.addEventListener('mousedown', (e) => {
            if (e.button === 2) { // Right click
                e.preventDefault();
                
                const rect = container.getBoundingClientRect();
                const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera({ x: mouseX, y: mouseY }, camera);
                
                const intersects = raycaster.intersectObjects(scene.children, true);
                
                if (intersects.length > 0) {
                    lookAtPoint.x = intersects[0].point.x;
                    lookAtPoint.y = intersects[0].point.y;
                    lookAtPoint.z = intersects[0].point.z;
                }
            }
        });

        // Prevent context menu on right click
        container.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Touch controls for mobile
        let lastTouchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let touchStartTime = 0;

        container.addEventListener('touchstart', (e) => {
            unlockAudio(); // Try to unlock on first touch
            touchStartTime = Date.now();
            
            if (e.touches.length === 1) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        container.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single finger - rotate
                const deltaX = e.touches[0].clientX - lastTouchX;
                const deltaY = e.touches[0].clientY - lastTouchY;
                
                rotation.y += deltaX * 0.01;
                rotation.x += deltaY * 0.01;
                rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two fingers - zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const delta = distance - lastTouchDistance;
                zoom = Math.max(5, Math.min(50, zoom - delta * 0.05));
                
                lastTouchDistance = distance;
            }
        });

        container.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // Quick tap launches firework
            if (touchDuration < 200 && e.changedTouches.length === 1) {
                launchFirework();
            }
        });

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom = Math.max(5, Math.min(50, zoom + e.deltaY * 0.01));
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>
